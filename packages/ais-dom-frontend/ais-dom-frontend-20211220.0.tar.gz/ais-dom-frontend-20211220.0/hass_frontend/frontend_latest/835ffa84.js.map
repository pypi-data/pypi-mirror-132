{"version":3,"file":"835ffa84.js","mappings":";;AAgEA;;;;;AASA;;;;AAYA;AACA;;;AAKA;AAEA;;;AAGA;AACA;;;AAIA;AAGA;;;AAKA;AAKA;;AAIA;;;AAIA;AAKA;;AAOA;;;;AAKA;;AAEA;;;;;AAOA;;AA/HA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;ACqEA;;AAKA;;AAKA;;AASA;;AAGA;;AASA;AAKA;;AAEA;AACA;AACA;AACA;AACA;AAIA;AAGA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA7GA","sources":["webpack://home-assistant-frontend/./src/components/ha-gauge.ts","webpack://home-assistant-frontend/./src/panels/lovelace/cards/hui-gauge-card.ts"],"sourcesContent":["import { css, LitElement, PropertyValues, svg, TemplateResult } from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport { ifDefined } from \"lit/directives/if-defined\";\nimport { styleMap } from \"lit/directives/style-map\";\nimport { formatNumber } from \"../common/number/format_number\";\nimport { afterNextRender } from \"../common/util/render-status\";\nimport { FrontendLocaleData } from \"../data/translation\";\nimport { getValueInPercentage, normalize } from \"../util/calculate\";\nimport { isSafari } from \"../util/is_safari\";\n\nconst getAngle = (value: number, min: number, max: number) => {\n  const percentage = getValueInPercentage(normalize(value, min, max), min, max);\n  return (percentage * 180) / 100;\n};\n\nexport interface LevelDefinition {\n  level: number;\n  stroke: string;\n}\n\n@customElement(\"ha-gauge\")\nexport class Gauge extends LitElement {\n  @property({ type: Number }) public min = 0;\n\n  @property({ type: Number }) public max = 100;\n\n  @property({ type: Number }) public value = 0;\n\n  @property({ type: String }) public valueText?: string;\n\n  @property() public locale!: FrontendLocaleData;\n\n  @property({ type: Boolean }) public needle?: boolean;\n\n  @property() public levels?: LevelDefinition[];\n\n  @property() public label = \"\";\n\n  @state() private _angle = 0;\n\n  @state() private _updated = false;\n\n  protected firstUpdated(changedProperties: PropertyValues) {\n    super.firstUpdated(changedProperties);\n    // Wait for the first render for the initial animation to work\n    afterNextRender(() => {\n      this._updated = true;\n      this._angle = getAngle(this.value, this.min, this.max);\n      this._rescale_svg();\n    });\n  }\n\n  protected updated(changedProperties: PropertyValues) {\n    super.updated(changedProperties);\n    if (!this._updated || !changedProperties.has(\"value\")) {\n      return;\n    }\n    this._angle = getAngle(this.value, this.min, this.max);\n    this._rescale_svg();\n  }\n\n  protected render() {\n    return svg`\n      <svg viewBox=\"0 0 100 50\" class=\"gauge\">\n        ${\n          !this.needle || !this.levels\n            ? svg`<path\n          class=\"dial\"\n          d=\"M 10 50 A 40 40 0 0 1 90 50\"\n        ></path>`\n            : \"\"\n        }\n\n        ${\n          this.levels\n            ? this.levels\n                .sort((a, b) => a.level - b.level)\n                .map((level, idx) => {\n                  let firstPath: TemplateResult | undefined;\n                  if (idx === 0 && level.level !== this.min) {\n                    const angle = getAngle(this.min, this.min, this.max);\n                    firstPath = svg`<path\n                        stroke=\"var(--info-color)\"\n                        class=\"level\"\n                        d=\"M\n                          ${50 - 40 * Math.cos((angle * Math.PI) / 180)}\n                          ${50 - 40 * Math.sin((angle * Math.PI) / 180)}\n                         A 40 40 0 0 1 90 50\n                        \"\n                      ></path>`;\n                  }\n                  const angle = getAngle(level.level, this.min, this.max);\n                  return svg`${firstPath}<path\n                      stroke=\"${level.stroke}\"\n                      class=\"level\"\n                      d=\"M\n                        ${50 - 40 * Math.cos((angle * Math.PI) / 180)}\n                        ${50 - 40 * Math.sin((angle * Math.PI) / 180)}\n                       A 40 40 0 0 1 90 50\n                      \"\n                    ></path>`;\n                })\n            : \"\"\n        }\n        ${\n          this.needle\n            ? svg`<path\n                class=\"needle\"\n                d=\"M 25 47.5 L 2.5 50 L 25 52.5 z\"\n                style=${ifDefined(\n                  !isSafari\n                    ? styleMap({ transform: `rotate(${this._angle}deg)` })\n                    : undefined\n                )}\n                transform=${ifDefined(\n                  isSafari ? `rotate(${this._angle} 50 50)` : undefined\n                )}\n              >\n              `\n            : svg`<path\n                class=\"value\"\n                d=\"M 90 50.001 A 40 40 0 0 1 10 50\"\n                style=${ifDefined(\n                  !isSafari\n                    ? styleMap({ transform: `rotate(${this._angle}deg)` })\n                    : undefined\n                )}\n                transform=${ifDefined(\n                  isSafari ? `rotate(${this._angle} 50 50)` : undefined\n                )}\n              >`\n        }\n        ${\n          // Workaround for https://github.com/home-assistant/frontend/issues/6467\n          isSafari\n            ? svg`<animateTransform\n                attributeName=\"transform\"\n                type=\"rotate\"\n                from=\"0 50 50\"\n                to=\"${this._angle} 50 50\"\n                dur=\"1s\"\n              />`\n            : \"\"\n        }\n        </path>\n      </svg>\n      <svg class=\"text\">\n        <text class=\"value-text\">\n          ${this.valueText || formatNumber(this.value, this.locale)} ${\n      this.label\n    }\n        </text>\n      </svg>`;\n  }\n\n  private _rescale_svg() {\n    // Set the viewbox of the SVG containing the value to perfectly\n    // fit the text\n    // That way it will auto-scale correctly\n    const svgRoot = this.shadowRoot!.querySelector(\".text\")!;\n    const box = svgRoot.querySelector(\"text\")!.getBBox()!;\n    svgRoot.setAttribute(\n      \"viewBox\",\n      `${box.x} ${box!.y} ${box.width} ${box.height}`\n    );\n  }\n\n  static get styles() {\n    return css`\n      :host {\n        position: relative;\n      }\n      .dial {\n        fill: none;\n        stroke: var(--primary-background-color);\n        stroke-width: 15;\n      }\n      .value {\n        fill: none;\n        stroke-width: 15;\n        stroke: var(--gauge-color);\n        transform-origin: 50% 100%;\n        transition: all 1s ease 0s;\n      }\n      .needle {\n        fill: var(--primary-text-color);\n        transform-origin: 50% 100%;\n        transition: all 1s ease 0s;\n      }\n      .level {\n        fill: none;\n        stroke-width: 15;\n      }\n      .gauge {\n        display: block;\n      }\n      .text {\n        position: absolute;\n        max-height: 40%;\n        max-width: 55%;\n        left: 50%;\n        bottom: -6%;\n        transform: translate(-50%, 0%);\n      }\n      .value-text {\n        font-size: 50px;\n        fill: var(--primary-text-color);\n        text-anchor: middle;\n      }\n    `;\n  }\n}\n","import { HassEntity } from \"home-assistant-js-websocket/dist/types\";\nimport {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  TemplateResult,\n} from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport { styleMap } from \"lit/directives/style-map\";\nimport { applyThemesOnElement } from \"../../../common/dom/apply_themes_on_element\";\nimport { fireEvent } from \"../../../common/dom/fire_event\";\nimport { computeStateName } from \"../../../common/entity/compute_state_name\";\nimport { isValidEntityId } from \"../../../common/entity/valid_entity_id\";\nimport \"../../../components/ha-card\";\nimport \"../../../components/ha-gauge\";\nimport { UNAVAILABLE } from \"../../../data/entity\";\nimport type { HomeAssistant } from \"../../../types\";\nimport { findEntities } from \"../common/find-entities\";\nimport { hasConfigOrEntityChanged } from \"../common/has-changed\";\nimport { createEntityNotFoundWarning } from \"../components/hui-warning\";\nimport type { LovelaceCard, LovelaceCardEditor } from \"../types\";\nimport type { GaugeCardConfig } from \"./types\";\n\nexport const severityMap = {\n  red: \"var(--error-color)\",\n  green: \"var(--success-color)\",\n  yellow: \"var(--warning-color)\",\n  normal: \"var(--info-color)\",\n};\n\n@customElement(\"hui-gauge-card\")\nclass HuiGaugeCard extends LitElement implements LovelaceCard {\n  public static async getConfigElement(): Promise<LovelaceCardEditor> {\n    await import(\"../editor/config-elements/hui-gauge-card-editor\");\n    return document.createElement(\"hui-gauge-card-editor\");\n  }\n\n  public static getStubConfig(\n    hass: HomeAssistant,\n    entities: string[],\n    entitiesFallback: string[]\n  ): GaugeCardConfig {\n    const includeDomains = [\"counter\", \"input_number\", \"number\", \"sensor\"];\n    const maxEntities = 1;\n    const entityFilter = (stateObj: HassEntity): boolean =>\n      !isNaN(Number(stateObj.state));\n\n    const foundEntities = findEntities(\n      hass,\n      maxEntities,\n      entities,\n      entitiesFallback,\n      includeDomains,\n      entityFilter\n    );\n\n    return { type: \"gauge\", entity: foundEntities[0] || \"\" };\n  }\n\n  @property({ attribute: false }) public hass?: HomeAssistant;\n\n  @state() private _config?: GaugeCardConfig;\n\n  public getCardSize(): number {\n    return 4;\n  }\n\n  public setConfig(config: GaugeCardConfig): void {\n    if (!config.entity) {\n      throw new Error(\"Entity must be specified\");\n    }\n    if (!isValidEntityId(config.entity)) {\n      throw new Error(\"Invalid entity\");\n    }\n\n    this._config = { min: 0, max: 100, ...config };\n  }\n\n  protected render(): TemplateResult {\n    if (!this._config || !this.hass) {\n      return html``;\n    }\n\n    const stateObj = this.hass.states[this._config.entity];\n\n    if (!stateObj) {\n      return html`\n        <hui-warning>\n          ${createEntityNotFoundWarning(this.hass, this._config.entity)}\n        </hui-warning>\n      `;\n    }\n\n    const entityState = Number(stateObj.state);\n\n    if (stateObj.state === UNAVAILABLE) {\n      return html`\n        <hui-warning\n          >${this.hass.localize(\n            \"ui.panel.lovelace.warning.entity_unavailable\",\n            \"entity\",\n            this._config.entity\n          )}</hui-warning\n        >\n      `;\n    }\n\n    if (isNaN(entityState)) {\n      return html`\n        <hui-warning\n          >${this.hass.localize(\n            \"ui.panel.lovelace.warning.entity_non_numeric\",\n            \"entity\",\n            this._config.entity\n          )}</hui-warning\n        >\n      `;\n    }\n\n    const name = this._config.name ?? computeStateName(stateObj);\n\n    // Use `stateObj.state` as value to keep formatting (e.g trailing zeros)\n    // for consistent value display across gauge, entity, entity-row, etc.\n    return html`\n      <ha-card @click=${this._handleClick} tabindex=\"0\">\n        <ha-gauge\n          .min=${this._config.min!}\n          .max=${this._config.max!}\n          .value=${stateObj.state}\n          .locale=${this.hass!.locale}\n          .label=${this._config!.unit ||\n          this.hass?.states[this._config!.entity].attributes\n            .unit_of_measurement ||\n          \"\"}\n          style=${styleMap({\n            \"--gauge-color\": this._computeSeverity(entityState),\n          })}\n          .needle=${this._config!.needle}\n          .levels=${this._config!.needle ? this._severityLevels() : undefined}\n        ></ha-gauge>\n        <div class=\"name\" .title=${name}>${name}</div>\n      </ha-card>\n    `;\n  }\n\n  protected shouldUpdate(changedProps: PropertyValues): boolean {\n    return hasConfigOrEntityChanged(this, changedProps);\n  }\n\n  protected updated(changedProps: PropertyValues): void {\n    super.updated(changedProps);\n    if (!this._config || !this.hass) {\n      return;\n    }\n\n    const oldHass = changedProps.get(\"hass\") as HomeAssistant | undefined;\n    const oldConfig = changedProps.get(\"_config\") as\n      | GaugeCardConfig\n      | undefined;\n\n    if (\n      !oldHass ||\n      !oldConfig ||\n      oldHass.themes !== this.hass.themes ||\n      oldConfig.theme !== this._config.theme\n    ) {\n      applyThemesOnElement(this, this.hass.themes, this._config.theme);\n    }\n  }\n\n  private _computeSeverity(numberValue: number): string | undefined {\n    if (this._config!.needle) {\n      return undefined;\n    }\n    const sections = this._config!.severity;\n\n    if (!sections) {\n      return severityMap.normal;\n    }\n\n    const sectionsArray = Object.keys(sections);\n    const sortable = sectionsArray.map((severity) => [\n      severity,\n      sections[severity],\n    ]);\n\n    for (const severity of sortable) {\n      if (severityMap[severity[0]] == null || isNaN(severity[1])) {\n        return severityMap.normal;\n      }\n    }\n    sortable.sort((a, b) => a[1] - b[1]);\n\n    if (numberValue >= sortable[0][1] && numberValue < sortable[1][1]) {\n      return severityMap[sortable[0][0]];\n    }\n    if (numberValue >= sortable[1][1] && numberValue < sortable[2][1]) {\n      return severityMap[sortable[1][0]];\n    }\n    if (numberValue >= sortable[2][1]) {\n      return severityMap[sortable[2][0]];\n    }\n    return severityMap.normal;\n  }\n\n  private _severityLevels() {\n    const sections = this._config!.severity;\n\n    if (!sections) {\n      return [{ level: 0, stroke: severityMap.normal }];\n    }\n\n    const sectionsArray = Object.keys(sections);\n    return sectionsArray.map((severity) => ({\n      level: sections[severity],\n      stroke: severityMap[severity],\n    }));\n  }\n\n  private _handleClick(): void {\n    fireEvent(this, \"hass-more-info\", { entityId: this._config!.entity });\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      ha-card {\n        cursor: pointer;\n        height: 100%;\n        overflow: hidden;\n        padding: 16px;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        flex-direction: column;\n        box-sizing: border-box;\n      }\n\n      ha-card:focus {\n        outline: none;\n        background: var(--divider-color);\n      }\n\n      ha-gauge {\n        width: 100%;\n        max-width: 250px;\n      }\n\n      .name {\n        text-align: center;\n        line-height: initial;\n        color: var(--primary-text-color);\n        width: 100%;\n        font-size: 15px;\n        margin-top: 8px;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"hui-gauge-card\": HuiGaugeCard;\n  }\n}\n"],"names":[],"sourceRoot":""}